

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>API Reference &mdash; AniSOAP 0.0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="_static/sg_gallery-rendered-html.css?v=1277b6f3" />
      <link rel="stylesheet" type="text/css" href="_static/custom.css?v=341189f5" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=d45e8c67"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Usage" href="usage.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            AniSOAP
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="auto_examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-anisoap.representations.ellipsoidal_density_projection">Representations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.representations.ellipsoidal_density_projection.EllipsoidalDensityProjection"><code class="docutils literal notranslate"><span class="pre">EllipsoidalDensityProjection</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#anisoap.representations.ellipsoidal_density_projection.EllipsoidalDensityProjection.features"><code class="docutils literal notranslate"><span class="pre">EllipsoidalDensityProjection.features</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#anisoap.representations.ellipsoidal_density_projection.EllipsoidalDensityProjection.feature_gradients"><code class="docutils literal notranslate"><span class="pre">EllipsoidalDensityProjection.feature_gradients</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#anisoap.representations.ellipsoidal_density_projection.EllipsoidalDensityProjection.power_spectrum"><code class="docutils literal notranslate"><span class="pre">EllipsoidalDensityProjection.power_spectrum()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#anisoap.representations.ellipsoidal_density_projection.EllipsoidalDensityProjection.transform"><code class="docutils literal notranslate"><span class="pre">EllipsoidalDensityProjection.transform()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.representations.ellipsoidal_density_projection.contract_pairwise_feat"><code class="docutils literal notranslate"><span class="pre">contract_pairwise_feat()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.representations.ellipsoidal_density_projection.pairwise_ellip_expansion"><code class="docutils literal notranslate"><span class="pre">pairwise_ellip_expansion()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.representations.radial_basis.GTORadialBasis"><code class="docutils literal notranslate"><span class="pre">GTORadialBasis</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#anisoap.representations.radial_basis.GTORadialBasis.calc_overlap_matrix"><code class="docutils literal notranslate"><span class="pre">GTORadialBasis.calc_overlap_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#anisoap.representations.radial_basis.GTORadialBasis.get_basis"><code class="docutils literal notranslate"><span class="pre">GTORadialBasis.get_basis()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#anisoap.representations.radial_basis.GTORadialBasis.get_num_radial_functions"><code class="docutils literal notranslate"><span class="pre">GTORadialBasis.get_num_radial_functions()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#anisoap.representations.radial_basis.GTORadialBasis.orthonormalize_basis"><code class="docutils literal notranslate"><span class="pre">GTORadialBasis.orthonormalize_basis()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#anisoap.representations.radial_basis.GTORadialBasis.plot_basis"><code class="docutils literal notranslate"><span class="pre">GTORadialBasis.plot_basis()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.representations.radial_basis.MonomialBasis"><code class="docutils literal notranslate"><span class="pre">MonomialBasis</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#anisoap.representations.radial_basis.MonomialBasis.calc_overlap_matrix"><code class="docutils literal notranslate"><span class="pre">MonomialBasis.calc_overlap_matrix()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#anisoap.representations.radial_basis.MonomialBasis.get_basis"><code class="docutils literal notranslate"><span class="pre">MonomialBasis.get_basis()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#anisoap.representations.radial_basis.MonomialBasis.get_num_radial_functions"><code class="docutils literal notranslate"><span class="pre">MonomialBasis.get_num_radial_functions()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#anisoap.representations.radial_basis.MonomialBasis.orthonormalize_basis"><code class="docutils literal notranslate"><span class="pre">MonomialBasis.orthonormalize_basis()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#anisoap.representations.radial_basis.MonomialBasis.plot_basis"><code class="docutils literal notranslate"><span class="pre">MonomialBasis.plot_basis()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.representations.radial_basis.gto_overlap"><code class="docutils literal notranslate"><span class="pre">gto_overlap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.representations.radial_basis.gto_prefactor"><code class="docutils literal notranslate"><span class="pre">gto_prefactor()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.representations.radial_basis.gto_square_norm"><code class="docutils literal notranslate"><span class="pre">gto_square_norm()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.representations.radial_basis.inverse_matrix_sqrt"><code class="docutils literal notranslate"><span class="pre">inverse_matrix_sqrt()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.representations.radial_basis.monomial_overlap"><code class="docutils literal notranslate"><span class="pre">monomial_overlap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.representations.radial_basis.monomial_prefactor"><code class="docutils literal notranslate"><span class="pre">monomial_prefactor()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.representations.radial_basis.monomial_square_norm"><code class="docutils literal notranslate"><span class="pre">monomial_square_norm()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-anisoap.utils.cyclic_list">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.utils.cyclic_list.CGRCacheList"><code class="docutils literal notranslate"><span class="pre">CGRCacheList</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#anisoap.utils.cyclic_list.CGRCacheList.clear_cache"><code class="docutils literal notranslate"><span class="pre">CGRCacheList.clear_cache()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#anisoap.utils.cyclic_list.CGRCacheList.get_val"><code class="docutils literal notranslate"><span class="pre">CGRCacheList.get_val()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#anisoap.utils.cyclic_list.CGRCacheList.insert"><code class="docutils literal notranslate"><span class="pre">CGRCacheList.insert()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#anisoap.utils.cyclic_list.CGRCacheList.keys"><code class="docutils literal notranslate"><span class="pre">CGRCacheList.keys()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.utils.metatensor_utils.cg_combine"><code class="docutils literal notranslate"><span class="pre">cg_combine()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.utils.metatensor_utils.standardize_keys"><code class="docutils literal notranslate"><span class="pre">standardize_keys()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.utils.moment_generator.compute_moments_diagonal_inefficient_implementation"><code class="docutils literal notranslate"><span class="pre">compute_moments_diagonal_inefficient_implementation()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.utils.moment_generator.compute_moments_inefficient_implementation"><code class="docutils literal notranslate"><span class="pre">compute_moments_inefficient_implementation()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.utils.moment_generator.compute_moments_single_variable"><code class="docutils literal notranslate"><span class="pre">compute_moments_single_variable()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.utils.monomial_iterator.TrivariateMonomialIndices"><code class="docutils literal notranslate"><span class="pre">TrivariateMonomialIndices</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#anisoap.utils.monomial_iterator.TrivariateMonomialIndices.find_idx"><code class="docutils literal notranslate"><span class="pre">TrivariateMonomialIndices.find_idx()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.utils.spherical_to_cartesian.prefact_minus1"><code class="docutils literal notranslate"><span class="pre">prefact_minus1()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.utils.spherical_to_cartesian.prefact_minus2"><code class="docutils literal notranslate"><span class="pre">prefact_minus2()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#anisoap.utils.spherical_to_cartesian.spherical_to_cartesian"><code class="docutils literal notranslate"><span class="pre">spherical_to_cartesian()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">AniSOAP</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">API Reference</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="api-reference">
<h1>API Reference<a class="headerlink" href="#api-reference" title="Link to this heading"></a></h1>
<section id="module-anisoap.representations.ellipsoidal_density_projection">
<span id="representations"></span><h2>Representations<a class="headerlink" href="#module-anisoap.representations.ellipsoidal_density_projection" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="anisoap.representations.ellipsoidal_density_projection.EllipsoidalDensityProjection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">anisoap.representations.ellipsoidal_density_projection.</span></span><span class="sig-name descname"><span class="pre">EllipsoidalDensityProjection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_angular</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radial_basis_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff_radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_gradients</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subtract_center_contribution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radial_gaussian_width</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_radial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation_key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'quaternion'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'quaternion'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_rcond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.ellipsoidal_density_projection.EllipsoidalDensityProjection" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class for computing spherical projection coefficients.</p>
<p>Compute the spherical projection coefficients for a system of ellipsoids
assuming a multivariate Gaussian density.</p>
<p>Initialize the calculator using the hyperparameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_angular</strong> (<em>int</em>) – Number of angular functions</p></li>
<li><p><strong>radial_basis</strong> (<em>_RadialBasis</em>) – The radial basis. Currently implemented are
‘gto’, ‘monomial’.</p></li>
<li><p><strong>compute_gradients</strong> (<em>bool</em>) – Compute gradients</p></li>
<li><p><strong>subtract_center_contribution</strong> (<em>bool</em>) – Subtract contribution from the central atom.</p></li>
<li><p><strong>rotation_key</strong> (<em>string</em>) – Key under which rotations are stored in ase frames arrays</p></li>
<li><p><strong>rotation_type</strong> (<em>string</em>) – Type of rotation object being passed. Currently implemented
are ‘quaternion’ and ‘matrix’</p></li>
<li><p><strong>max_radial</strong> (<em>None</em><em>, </em><em>int</em><em>, </em><em>list</em><em> of </em><em>int</em>) – Number of radial bases to use. Can either correspond to number of
bases per spherical harmonic or a value to use with every harmonic.
If <cite>None</cite>, then for every <cite>l</cite>, <cite>(max_angular - l) // 2 + 1</cite> will
be used.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="anisoap.representations.ellipsoidal_density_projection.EllipsoidalDensityProjection.features">
<span class="sig-name descname"><span class="pre">features</span></span><a class="headerlink" href="#anisoap.representations.ellipsoidal_density_projection.EllipsoidalDensityProjection.features" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="anisoap.representations.ellipsoidal_density_projection.EllipsoidalDensityProjection.feature_gradients">
<span class="sig-name descname"><span class="pre">feature_gradients</span></span><a class="headerlink" href="#anisoap.representations.ellipsoidal_density_projection.EllipsoidalDensityProjection.feature_gradients" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anisoap.representations.ellipsoidal_density_projection.EllipsoidalDensityProjection.power_spectrum">
<span class="sig-name descname"><span class="pre">power_spectrum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frames</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sum_over_samples</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.ellipsoidal_density_projection.EllipsoidalDensityProjection.power_spectrum" title="Link to this definition"></a></dt>
<dd><p>Function to compute the power spectrum of AniSOAP</p>
<p>computes the power spectrum of AniSOAP with the inputs of AniSOAP hyperparameters
and ellipsoidal frames using ellipsoidal density projection. It checks if
each ellipsoidal frame contains all required attributes and processes
Clebsch-Gordan coefficients for the angular component of the AniSOAP descriptors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frames</strong> (<em>list</em>) – A list of ellipsoidal frames, where each frame contains attributes:
‘c_diameter[1]’, ‘c_diameter[2]’, ‘c_diameter[3]’, ‘c_q’, ‘positions’, and ‘numbers’.
It only accepts c_q for the angular attribute of each frame.</p></li>
<li><p><strong>sum_over_sample</strong> (<em>bool</em>) – A function that returns the sum of coefficients of the frames in the sample.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>x_asoap_raw when kwarg sum_over_samples=True or mvg_nu2 when sum_over_samples=False</em></p></li>
<li><p><strong>x_asoap_raw</strong> (<em>A 2-dimensional np.array with shape (n_samples, n_features). This AniSOAP power spectrum aggregates (sums) over each sample.</em>)</p></li>
<li><p><strong>mvg_nu2</strong> (<em>a TensorMap of unaggregated power spectrum features.</em>)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anisoap.representations.ellipsoidal_density_projection.EllipsoidalDensityProjection.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frames</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rust_moments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.ellipsoidal_density_projection.EllipsoidalDensityProjection.transform" title="Link to this definition"></a></dt>
<dd><p>Computes features and gradients for frames</p>
<p>Computes the features and (if compute_gradients == True) gradients
for all the provided frames. The features and gradients are stored in
features and feature_gradients attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frames</strong> (<em>ase.Atoms</em>) – List containing all ase.Atoms types</p></li>
<li><p><strong>show_progress</strong> (<em>bool</em>) – Show progress bar for frame analysis and feature generation</p></li>
<li><p><strong>normalize</strong> (<em>bool</em>) – Whether to perform Lowdin Symmetric Orthonormalization or not.</p></li>
<li><p><strong>rust_moments</strong> (<em>bool</em>) – Use the ported rust code, which should result in increased speed. Default = True.
In the future, once we ensure integrity checks with the original python code,
this kwarg will be deprecated, and the rust version will always be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>None, but stores the projection coefficients and (if desired)</em></p></li>
<li><p>gradients as arrays as <cite>features</cite> and <cite>features_gradients</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anisoap.representations.ellipsoidal_density_projection.contract_pairwise_feat">
<span class="sig-prename descclassname"><span class="pre">anisoap.representations.ellipsoidal_density_projection.</span></span><span class="sig-name descname"><span class="pre">contract_pairwise_feat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pair_ellip_feat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">types</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.ellipsoidal_density_projection.contract_pairwise_feat" title="Link to this definition"></a></dt>
<dd><p>Function to sum over the pairwise expansion</p>
<div class="math notranslate nohighlight">
\[\sum_{j \in a} \langle anlm|\rho_{ij} \rangle
    = \langle anlm|\rho_i \rangle\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pair_ellip_feat</strong> (<em>metatensor.TensorMap</em>) – TensorMap returned from “pairwise_ellip_expansion()” with keys
(types_1, types_2,l) enumerating the possible species pairs and the
angular channels.</p></li>
<li><p><strong>types</strong> (<em>list</em><em> of </em><em>ints</em>) – List of atomic numbers present across the data frames</p></li>
<li><p><strong>show_progress</strong> (<em>bool</em>) – Show progress bar for frame analysis and feature generation</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A metatensor TensorMap with keys (types, l) “types” takes the value
of the atomic numbers present in the dataset and “l” is the angular
channel. Each block of this tensormap has as samples (“type”, “center”),
yielding the indices of the frames and atoms that correspond to “species”
are present. block.value is a 3D array of the form (num_samples, num_components, properties)
where num_components take on the same values as in the pair_ellip_feat_feat.block.
block.properties now has an additional index for neighbor_species that
corresponds to “a” in <span class="math notranslate nohighlight">\(\langle anlm|rho_i \rangle\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>TensorMap</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anisoap.representations.ellipsoidal_density_projection.pairwise_ellip_expansion">
<span class="sig-prename descclassname"><span class="pre">anisoap.representations.ellipsoidal_density_projection.</span></span><span class="sig-name descname"><span class="pre">pairwise_ellip_expansion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">types</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame_to_global_atom_idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation_matrices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ellipsoid_lengths</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sph_to_cart</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radial_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rust_moments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.ellipsoidal_density_projection.pairwise_ellip_expansion" title="Link to this definition"></a></dt>
<dd><p>Computes pairwise expansion</p>
<p>Function to compute the pairwise expansion <span class="math notranslate nohighlight">\(\langle anlm|\rho_{ij} \rangle\)</span>
by combining the moments and the spherical to Cartesian transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lmax</strong> (<em>int</em>) – Maximum angular</p></li>
<li><p><strong>neighbor_list</strong> (<em>metatensor.TensorMap</em>) – Full neighborlist with keys (types_1, types_2) enumerating the possible
species pairs. Each block contains as samples, the atom indices of
(first_atom, second_atom) that correspond to the key, and block.value is
a 3D array of the form (num_samples, num_components,properties), with
num_components=3 corresponding to the (x,y,z) components of the vector
from first_atom to second_atom. Depending on the cutoff some species
pairs may not appear. Self pairs are not present but in PBC, pairs between
copies of the same atom are accounted for.</p></li>
<li><p><strong>types</strong> (<em>list</em><em> of </em><em>ints</em>) – List of atomic numbers present across the data frames</p></li>
<li><p><strong>frame_to_global_atom_idx</strong> (<em>list</em><em> of </em><em>ints</em>) – The length of the list equals the number of frames, each entry enumerating
the number of atoms in corresponding frame</p></li>
<li><p><strong>rotation_matrices</strong> (<em>np.array</em><em> of </em><em>dimension</em><em> (</em><em>(</em><em>num_atoms</em><em>,</em><em>3</em><em>,</em><em>3</em><em>)</em><em>)</em>)</p></li>
<li><p><strong>ellipsoid_lengths</strong> (<em>np.array</em><em> of </em><em>dimension</em><em> (</em><em>(</em><em>num_atoms</em><em>,</em><em>3</em><em>)</em><em>)</em>)</p></li>
<li><p><strong>radial_basis</strong> (<em>Instance</em><em> of </em><em>the RadialBasis Class</em>) – anisoap.representations.radial_basis.RadialBasis that has been instantiated
appropriately with the cutoff radius, radial basis type.</p></li>
<li><p><strong>show_progress</strong> (<em>bool</em>) – Show progress bar for frame analysis and feature generation</p></li>
<li><p><strong>rust_moments</strong> (<em>bool</em>) – Use the ported rust code, which should result in increased speed. Default = True.
In the future, once we ensure integrity checks with the original python code,
this kwarg will be deprecated, and the rust version will always be used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A metatensor TensorMap with keys (types_1, types_2, l) where
(“types_1”, “types_2”) is key in the neighbor_list and “l” is the
angular channel. Each block of this tensormap has the same samples as the
corresponding block of the neighbor_list. block.value is a 3D array of
the form (num_samples, num_components, properties) where num_components
form the 2*l+1 values for the corresponding angular channel and the
properties dimension corresponds to the radial channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>TensorMap</p>
</dd>
</dl>
</dd></dl>

<dl class="py class" id="module-anisoap.representations.radial_basis">
<dt class="sig sig-object py" id="anisoap.representations.radial_basis.GTORadialBasis">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">anisoap.representations.radial_basis.</span></span><span class="sig-name descname"><span class="pre">GTORadialBasis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_angular</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff_radius</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radial_gaussian_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_radial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.radial_basis.GTORadialBasis" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_RadialBasis</span></code></p>
<p>A subclass of _RadialBasis that contains attributes and methods required for the GTO basis.</p>
<p>The GTO basis of order n is defined to be <span class="math notranslate nohighlight">\(R(r) = r^n e^{(-r^2/(2\sigma^2))}\)</span>.</p>
<p>For GTO basis with defined nmax and lmax, our radial basis set consists of GTO of order n=0 to n=lmax + 2nmax.</p>
<p>For GTO basis with coupled nmax and lmax, our radial basis set consists of GTO of order n=0 to n=max(lmax + 2nmax)</p>
<dl class="py method">
<dt class="sig sig-object py" id="anisoap.representations.radial_basis.GTORadialBasis.calc_overlap_matrix">
<span class="sig-name descname"><span class="pre">calc_overlap_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.radial_basis.GTORadialBasis.calc_overlap_matrix" title="Link to this definition"></a></dt>
<dd><p>Computes the overlap matrix for GTOs.</p>
<p>The overlap matrix is a Gram matrix whose entries are the overlap:</p>
<div class="math notranslate nohighlight">
\[S_{ij} = \int_0^\infty dr r^2 \phi_i \phi_j\]</div>
<p>The overlap has an analytic solution (see above functions).</p>
<p>The overlap matrix is the first step to generating an orthonormal basis
set of functions (Lodwin Symmetric Orthonormalization). The actual
orthonormalization matrix cannot be fully precomputed because each tensor
block uses a different set of GTOs. Hence, we precompute the full overlap
matrix of dim l_max, and while orthonormalizing each tensor block, we
generate the respective orthonormal matrices from slices of the full
overlap matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The overlap matrix</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>2D array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anisoap.representations.radial_basis.GTORadialBasis.get_basis">
<span class="sig-name descname"><span class="pre">get_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.radial_basis.GTORadialBasis.get_basis" title="Link to this definition"></a></dt>
<dd><p>Evaluate orthonormalized GTO basis functions on mesh rs.</p>
<p>If lmax and nmax defined, then the number of functions outputted is lmax*(nmax+1)</p>
<p>If lmax and nmax coupled, then the number of functions outputted is
<span class="math notranslate nohighlight">\(\sum_{l=0}^{\text{lmax}} (\text{number_of_radial_functions_per_l})\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rs</strong> (<em>np.array</em>) – a mesh to evaluate the basis functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a matrix containing orthonormalized GTO basis functions evaluated on rs</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anisoap.representations.radial_basis.GTORadialBasis.get_num_radial_functions">
<span class="sig-name descname"><span class="pre">get_num_radial_functions</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.radial_basis.GTORadialBasis.get_num_radial_functions" title="Link to this definition"></a></dt>
<dd><p>Output the number of radial basis functions considered per value of l.
If max_angular and max_radial are both specified, then the list will contain repeated values of max_radial
Otherwise, the outputted list will specify the number of radial basis functions per l, which may be automatically
calculated if max_radial=None. If a custom list of max_radial is specified when initializing, then it will
return the same inputted list.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The attribute <cite>self.num_radial_functions</cite>, which is a list containing
the number of radial basis functions considered per <cite>l</cite>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anisoap.representations.radial_basis.GTORadialBasis.orthonormalize_basis">
<span class="sig-name descname"><span class="pre">orthonormalize_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">features</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TensorMap</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.radial_basis.GTORadialBasis.orthonormalize_basis" title="Link to this definition"></a></dt>
<dd><p>Applies in-place orthonormalization on the features.</p>
<p>Apply an in-place orthonormalization on the features, using Lodwin Symmetric
Orthonormalization. Each block in the features TensorMap uses a GTO set
of l + 2n, so we must take the appropriate slices of the overlap matrix
to compute the orthonormalization matrix. An instructive example of Lodwin
Symmetric Orthonormalization of a 2-element basis set is found here:
<a class="reference external" href="https://booksite.elsevier.com/9780444594365/downloads/16755_10030.pdf">https://booksite.elsevier.com/9780444594365/downloads/16755_10030.pdf</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>features</strong> (<em>TensorMap</em>) – contains blocks whose values we wish to orthonormalize. Note that
features is modified in place, so a copy of features must be made
before the function if you wish to retain the unnormalized values.</p></li>
<li><p><strong>radial_basis</strong> (<em>RadialBasis</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>features containing values multiplied by normalization factors.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>TensorMap</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anisoap.representations.radial_basis.GTORadialBasis.plot_basis">
<span class="sig-name descname"><span class="pre">plot_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.radial_basis.GTORadialBasis.plot_basis" title="Link to this definition"></a></dt>
<dd><p>Plot the normalized basis functions used in calculating the expansion
coefficients</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n_r</strong> (<em>int</em>) – number of mesh points. Default: 100</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="anisoap.representations.radial_basis.MonomialBasis">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">anisoap.representations.radial_basis.</span></span><span class="sig-name descname"><span class="pre">MonomialBasis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_angular</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff_radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_radial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.radial_basis.MonomialBasis" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">_RadialBasis</span></code></p>
<p>A subclass of _RadialBasis that contains attributes and methods required for
the Monomial basis.</p>
<p>The monomial basis of order n is defined to be <span class="math notranslate nohighlight">\(R(r) = r^n\)</span>.</p>
<p>For monomial basis with defined <span class="math notranslate nohighlight">\(n_{\text{max}}\)</span> and <span class="math notranslate nohighlight">\(l_{\text{max}}\)</span>,
our radial basis set consists of monomials of order <span class="math notranslate nohighlight">\(n=0\)</span> to
<span class="math notranslate nohighlight">\(n=l_{\text{max}} + 2n_{\text{max}}\)</span>.</p>
<p>For monomial basis with coupled <span class="math notranslate nohighlight">\(n_{\text{max}}\)</span> and <span class="math notranslate nohighlight">\(l_{\text{max}}\)</span>,
our radial basis set consists of monomials of order <span class="math notranslate nohighlight">\(n=0\)</span> to
<span class="math notranslate nohighlight">\(n=\max{l_{\text{max}} + 2n_{\text{max}}}\)</span></p>
<p>Monomials are not square-integrable from <span class="math notranslate nohighlight">\([0, \infty]\)</span>, so we orthonormalize
by integrating up to the cutoff radius</p>
<dl class="py method">
<dt class="sig sig-object py" id="anisoap.representations.radial_basis.MonomialBasis.calc_overlap_matrix">
<span class="sig-name descname"><span class="pre">calc_overlap_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.radial_basis.MonomialBasis.calc_overlap_matrix" title="Link to this definition"></a></dt>
<dd><p>Computes the overlap matrix for Monomnials over a fixed interval.</p>
<p>The overlap matrix is a Gram matrix whose entries are the overlap:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[S_{ij} = \int_{0}^{r_{cut}} dr r^2 \phi_i \phi_j\]</div>
</div></blockquote>
<p>The overlap has an analytic solution (see above functions).</p>
<p>The overlap matrix is the first step to generating an orthonormal basis set of functions (Lodwin Symmetric
Orthonormalization). The actual orthonormalization matrix cannot be fully precomputed because each tensor
block use a different set of bases. Hence, we precompute the full overlap matrix of dim l_max, and while
orthonormalizing each tensor block, we generate the respective orthonormal matrices from slices of the full
overlap matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The overlap matrix</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>2D array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anisoap.representations.radial_basis.MonomialBasis.get_basis">
<span class="sig-name descname"><span class="pre">get_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.radial_basis.MonomialBasis.get_basis" title="Link to this definition"></a></dt>
<dd><p>Evaluate orthonormalized monomial basis functions on mesh rs.</p>
<p>If lmax and nmax defined, then the number of functions outputted is lmax*(nmax+1)</p>
<p>If lmax and nmax coupled, then the number of functions outputted is <span class="math notranslate nohighlight">\(\sum_{l=0}^{lmax} (number\_of\_radial\_functions\_per\_l)\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rs</strong> (<em>np.array</em>) – a mesh to evaluate the basis functions</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a matrix containing orthonormalized monomial basis functions evaluated on rs</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anisoap.representations.radial_basis.MonomialBasis.get_num_radial_functions">
<span class="sig-name descname"><span class="pre">get_num_radial_functions</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.radial_basis.MonomialBasis.get_num_radial_functions" title="Link to this definition"></a></dt>
<dd><p>Output the number of radial basis functions considered per value of l.
If max_angular and max_radial are both specified, then the list will contain repeated values of max_radial
Otherwise, the outputted list will specify the number of radial basis functions per l, which may be automatically
calculated if max_radial=None. If a custom list of max_radial is specified when initializing, then it will
return the same inputted list.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The attribute <cite>self.num_radial_functions</cite>, which is a list containing
the number of radial basis functions considered per <cite>l</cite>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anisoap.representations.radial_basis.MonomialBasis.orthonormalize_basis">
<span class="sig-name descname"><span class="pre">orthonormalize_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">features</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TensorMap</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.radial_basis.MonomialBasis.orthonormalize_basis" title="Link to this definition"></a></dt>
<dd><p>Apply an in-place orthonormalization on the features, using Lodwin Symmetric Orthonormalization.
Each block in the features TensorMap uses a basis set of l + 2n, so we must take the appropriate slices of
the overlap matrix to compute the orthonormalization matrix.
An instructive example of Lodwin Symmetric Orthonormalization of a 2-element basis set is found here:
<a class="reference external" href="https://booksite.elsevier.com/9780444594365/downloads/16755_10030.pdf">https://booksite.elsevier.com/9780444594365/downloads/16755_10030.pdf</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>features</strong> (<em>TensorMap</em>) – A TensorMap whose blocks’ values we wish to orthonormalize. Note that
<cite>features</cite> is modified in place, so a copy of <cite>features</cite> must be made
before the function if you wish to retain the unnormalized values.</p></li>
<li><p><strong>radial_basis</strong> (<em>_RadialBasis</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>features containing values multiplied by proper normalization factors.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>TensorMap</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anisoap.representations.radial_basis.MonomialBasis.plot_basis">
<span class="sig-name descname"><span class="pre">plot_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.radial_basis.MonomialBasis.plot_basis" title="Link to this definition"></a></dt>
<dd><p>Plot the normalized basis functions used in calculating the expansion
coefficients</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n_r</strong> (<em>int</em>) – number of mesh points. Default: 100</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anisoap.representations.radial_basis.gto_overlap">
<span class="sig-prename descclassname"><span class="pre">anisoap.representations.radial_basis.</span></span><span class="sig-name descname"><span class="pre">gto_overlap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_m</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.radial_basis.gto_overlap" title="Link to this definition"></a></dt>
<dd><p>Compute overlap of two <em>normalized</em> GTOs</p>
<p>Note that the overlap of two GTOs can be modeled as the square norm of one
GTO, with an effective <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(\sigma\)</span>. All we need to do is to
calculate those effective parameters, then compute the normalization prefactor.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\langle \phi_n, \phi_m \rangle &amp;= \int_0^\infty dr \, r^2 r^n e^{-r^2/(2\sigma_n^2)} \, r^m  e^{-r^2/(2\sigma_m^2)} \\
                               &amp;= \int_0^\infty dr \, r^2 \lvert r^{(n+m)/2} e^{-r^2/4 (1/\sigma_n^2 + 1/\sigma_m^2)}\rvert^2 \\
                               &amp;= \int_0^\infty dr \, r^2 r^n_\text{eff} e^{-r^2/(2\sigma_\text{eff}^2)}\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – order of the first GTO</p></li>
<li><p><strong>m</strong> – order of the second GTO</p></li>
<li><p><strong>sigma_n</strong> – sigma parameter of the first GTO</p></li>
<li><p><strong>sigma_m</strong> – sigma parameter of the second GTO</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>overlap of the two normalized GTOs</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anisoap.representations.radial_basis.gto_prefactor">
<span class="sig-prename descclassname"><span class="pre">anisoap.representations.radial_basis.</span></span><span class="sig-name descname"><span class="pre">gto_prefactor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.radial_basis.gto_prefactor" title="Link to this definition"></a></dt>
<dd><p>Computes the normalization prefactor of an unnormalized GTO.</p>
<p>This prefactor is simply <span class="math notranslate nohighlight">\(\frac{1}{\sqrt{\text{square_norm_area}}}\)</span>.
Scaling a GTO by this prefactor will ensure that the GTO has square norm
equal to 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – order of GTO</p></li>
<li><p><strong>sigma</strong> – width of GTO</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The normalization constant</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anisoap.representations.radial_basis.gto_square_norm">
<span class="sig-prename descclassname"><span class="pre">anisoap.representations.radial_basis.</span></span><span class="sig-name descname"><span class="pre">gto_square_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.radial_basis.gto_square_norm" title="Link to this definition"></a></dt>
<dd><p>Compute the square norm of GTOs (inner product of itself over <span class="math notranslate nohighlight">\(R^3\)</span>).</p>
<p>An unnormalized GTO of order n is <span class="math notranslate nohighlight">\(\phi_n = r^n  e^{-r^2/(2*\sigma^2)}\)</span>
The square norm of the unnormalized GTO has an analytic solution:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\braket{\phi_n | \phi_n} &amp;= \int_0^\infty dr \, r^2 \lvert\phi_n\rvert^2 \\
                         &amp;=  \frac{1}{2} \sigma^{2n+3} \Gamma(n+\frac{3}{2})\end{split}\]</div>
<p>This function uses the above expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – order of the GTO</p></li>
<li><p><strong>sigma</strong> – width of the GTO</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The square norm of the unnormalized GTO</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anisoap.representations.radial_basis.inverse_matrix_sqrt">
<span class="sig-prename descclassname"><span class="pre">anisoap.representations.radial_basis.</span></span><span class="sig-name descname"><span class="pre">inverse_matrix_sqrt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcond</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.radial_basis.inverse_matrix_sqrt" title="Link to this definition"></a></dt>
<dd><p>Returns the inverse matrix square root.</p>
<p>The inverse square root of the overlap matrix (or slices of the overlap matrix)
yields the orthonormalization matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix</strong> (<em>np.array</em>) – Symmetric square matrix to find the inverse square root of</p></li>
<li><p><strong>rcond</strong> (<em>float</em>) – Lower bound for eigenvalues for inverse square root</p></li>
<li><p><strong>tol</strong> (<em>float</em>) – Tolerance for differences between original matrix and reconstruction via
inverse square root</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(S^{-1/2}\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>inverse_sqrt_matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anisoap.representations.radial_basis.monomial_overlap">
<span class="sig-prename descclassname"><span class="pre">anisoap.representations.radial_basis.</span></span><span class="sig-name descname"><span class="pre">monomial_overlap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_cut</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.radial_basis.monomial_overlap" title="Link to this definition"></a></dt>
<dd><p>Compute overlap of two <em>normalized</em> monomials</p>
<p>Note that the overlap of two monomials can be modeled as the square norm of
one monomial, with an effective n. All we need to do is to calculate those
effective parameters, then compute the normalization:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\begin{split}\langle \phi_n, \phi_m \rangle &amp;= \int_0^\infty dr r^2 r^n r^m \\
                               &amp;= \int_0^{r_{cut}} dr r^2 |r^{(n+m)/2}|^2 \\
                               &amp;= \int_0^{r_{cut}} dr r^2 |r^{n_{eff}}|^2\end{split}\]</div>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> – order of the first monomial</p></li>
<li><p><strong>m</strong> – order of the second monomial</p></li>
<li><p><strong>r_cut</strong> (<em>float</em>) – cutoff radius</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>overlap of the two normalized monomial</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anisoap.representations.radial_basis.monomial_prefactor">
<span class="sig-prename descclassname"><span class="pre">anisoap.representations.radial_basis.</span></span><span class="sig-name descname"><span class="pre">monomial_prefactor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_cut</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.radial_basis.monomial_prefactor" title="Link to this definition"></a></dt>
<dd><p>Computes the normalization prefactor of an unnormalized monomial basis.
This prefactor is simply <span class="math notranslate nohighlight">\(1/\sqrt{square\_norm\_area}\)</span>.
Scaling a basis by this prefactor will ensure that the basis has square norm equal to 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> – order of the basis</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>normalization constant</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anisoap.representations.radial_basis.monomial_square_norm">
<span class="sig-prename descclassname"><span class="pre">anisoap.representations.radial_basis.</span></span><span class="sig-name descname"><span class="pre">monomial_square_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r_cut</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.representations.radial_basis.monomial_square_norm" title="Link to this definition"></a></dt>
<dd><p>Compute the square norm of monomials (inner product of itself over R^3).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> – order of the basis</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The square norm of the unnormalized basis</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-anisoap.utils.cyclic_list">
<span id="utilities"></span><h2>Utilities<a class="headerlink" href="#module-anisoap.utils.cyclic_list" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="anisoap.utils.cyclic_list.CGRCacheList">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">anisoap.utils.cyclic_list.</span></span><span class="sig-name descname"><span class="pre">CGRCacheList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.utils.cyclic_list.CGRCacheList" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>This is a simple class that only exists to be used as a “private” cache
for computed ClebschGordanReal matrices (self._cg)</p>
<p>It only stores last n CG matrices computed for distinct l_max values. Since
it is specialized to store (l_max, cg matrix) pair, it is NOT supposed to be
used to cache any other things. While type of “value” (in <cite>(key, value)</cite> pair)
does not matter as much, the type of <cite>key</cite> MUST BE A 32-BIT INTEGER with
most significant bit unused, as it performs bitwise operations on the most
significant bit to store and check the replacement flags.</p>
<p>It will replace the entries using something called “clock algorithm” for page
replacement, which mimics the “least recently used” algorithm but with less
computation requirement.</p>
<p>[Link to clock algorithm](<a class="reference external" href="https://en.wikipedia.org/wiki/Page_replacement_algorithm#Clock">https://en.wikipedia.org/wiki/Page_replacement_algorithm#Clock</a>)</p>
<dl class="py method">
<dt class="sig sig-object py" id="anisoap.utils.cyclic_list.CGRCacheList.clear_cache">
<span class="sig-name descname"><span class="pre">clear_cache</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#anisoap.utils.cyclic_list.CGRCacheList.clear_cache" title="Link to this definition"></a></dt>
<dd><p>Resets the cache (makes list empty)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anisoap.utils.cyclic_list.CGRCacheList.get_val">
<span class="sig-name descname"><span class="pre">get_val</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span></span></span><a class="headerlink" href="#anisoap.utils.cyclic_list.CGRCacheList.get_val" title="Link to this definition"></a></dt>
<dd><p>Obtains the value for given key. Raises IndexError if the given key
is not found in the list.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anisoap.utils.cyclic_list.CGRCacheList.insert">
<span class="sig-name descname"><span class="pre">insert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#anisoap.utils.cyclic_list.CGRCacheList.insert" title="Link to this definition"></a></dt>
<dd><p>This insert algorithm mimics the “clock algorithm” for page replacement
technique. The algorithm works like this:
1. Get the entry that the “clock hand” (self._ins_index) points to.
2. Keep advancing the “clock hand” until key with replacement flag = 0
is found. Replacement flag, in this case, is the most significant bit
3. Insert the new [key, value] pair into the list, with replacement flag = 1.
Advance “clock hand” by one position.
Note that clock hand wraps around the list, should it reach the end of the list.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anisoap.utils.cyclic_list.CGRCacheList.keys">
<span class="sig-name descname"><span class="pre">keys</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#anisoap.utils.cyclic_list.CGRCacheList.keys" title="Link to this definition"></a></dt>
<dd><p>Return list of keys, with keys</p>
</dd></dl>

</dd></dl>

<dl class="py function" id="module-anisoap.utils.metatensor_utils">
<dt class="sig sig-object py" id="anisoap.utils.metatensor_utils.cg_combine">
<span class="sig-prename descclassname"><span class="pre">anisoap.utils.metatensor_utils.</span></span><span class="sig-name descname"><span class="pre">cg_combine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feature_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clebsch_gordan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other_keys_match</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.utils.metatensor_utils.cg_combine" title="Link to this definition"></a></dt>
<dd><p>Performs a CG product of two sets of equivariants.</p>
<p>The only requirement is that sparse indices are labeled as
(“inversion_sigma”, “spherical_harmonics_l”, “order_nu”).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_a</strong> – First set of equivariants</p></li>
<li><p><strong>x_b</strong> – Second set of equivariants</p></li>
<li><p><strong>feature_names</strong> (<em>list</em><em>, </em><em>optional</em>) – Overrides automatically-generated names of output features.  By default,
all other key labels are combined via their outer product, i.e. if there
is a key-side <cite>neighbor-species</cite> in both <cite>x_a</cite> and <cite>x_b</cite>, the returned
keys will have two <cite>neighbor_species</cite> labels, corresponding to the parent
features.</p></li>
<li><p><strong>clebsch_gordan</strong> (<em>ClebschGordanReal</em><em>, </em><em>optional</em>)</p></li>
<li><p><strong>lcut</strong> (<em>np.ndarray</em><em>(</em><em>)</em>) – Cutoff in new features</p></li>
<li><p><strong>other_keys_match</strong> (<em>list</em><em>, </em><em>optional</em>) – List of keys that should match.  These will not need to have their outer
product taken, but will instead be merged into a new key.  For instance,
passing <cite>[“types center”]</cite> will combine the keys with the same type
center, yielding a single key with the same types_center in the results.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Clebsch-Gordan product of <cite>x_a</cite> and <cite>x_b</cite></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>TensorMap</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anisoap.utils.metatensor_utils.standardize_keys">
<span class="sig-prename descclassname"><span class="pre">anisoap.utils.metatensor_utils.</span></span><span class="sig-name descname"><span class="pre">standardize_keys</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">descriptor</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.utils.metatensor_utils.standardize_keys" title="Link to this definition"></a></dt>
<dd><p>Standardize the naming scheme of density expansion coefficient blocks (nu=1)</p>
</dd></dl>

<dl class="py function" id="module-anisoap.utils.moment_generator">
<dt class="sig sig-object py" id="anisoap.utils.moment_generator.compute_moments_diagonal_inefficient_implementation">
<span class="sig-prename descclassname"><span class="pre">anisoap.utils.moment_generator.</span></span><span class="sig-name descname"><span class="pre">compute_moments_diagonal_inefficient_implementation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">principal_components</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxdeg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.utils.moment_generator.compute_moments_diagonal_inefficient_implementation" title="Link to this definition"></a></dt>
<dd><p>Computes all moments for a diagonal dilation matrix.</p>
<p>The implementation focuses on conceptual simplicity, while sacrificing memory
efficiency.  To be specific, the <cite>moments</cite> array allows access to the value
of the moment <span class="math notranslate nohighlight">\(\langle x^{n_0}  y^{n_1}  z^{n_2} \rangle\)</span> simply as
<cite>moments[n0, n1, n2]</cite>.  This leads to more intuitive code, at the cost of
wasting around a third of the memory in the array to store zeros.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>principal_components</strong> (<em>np.ndarray</em><em> of </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em>) – Array containing the three principal components</p></li>
<li><p><strong>a</strong> (<em>np.ndarray</em><em> of </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em>) – Vectorial center of the trivariate Gaussian</p></li>
<li><p><strong>maxdeg</strong> (<em>int</em>) – Maximum degree for which the moments need to be computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>Moments calculated.  <cite>moments[n0,n1,n2]</cite> is the <span class="math notranslate nohighlight">\(\left(n_0,n_1,n_2\right)^\text{th}\)</span>
moment of the Gaussian defined as</p>
<div class="math notranslate nohighlight">
\[\langle x^{n_0}  y^{n_1}  z^{n_2} \rangle =
    \int(x^{n_0}  y^{n_1}  z^{n_2}) e^{-\frac{1}{2}(r-a)^T \Sigma (r-a)} dx\,dy\,dz\,
    \sum_{i=1}^{\infty} x_{i}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Sigma\)</span> is the covariance matrix.</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray of shape (3, <cite>maxdeg</cite> + 1)</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The term “moments” in probability theory are defined for normalized Gaussian
distributions. Here, we take the Gaussian without prefactor, meaning that
all moments are scaled by a global factor.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anisoap.utils.moment_generator.compute_moments_inefficient_implementation">
<span class="sig-prename descclassname"><span class="pre">anisoap.utils.moment_generator.</span></span><span class="sig-name descname"><span class="pre">compute_moments_inefficient_implementation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxdeg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.utils.moment_generator.compute_moments_inefficient_implementation" title="Link to this definition"></a></dt>
<dd><p>Computes all moments for a general dilation matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>np.ndarray</em><em> of </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>3</em><em>)</em>) – Dilation matrix of the Gaussian that determines its shape. It can be
written as <span class="math notranslate nohighlight">\(\mathbf{A} = \mathbf{R}\mathbf{D}\mathbf{R}^T\)</span>, where
R is a rotation matrix that specifies the orientation of the three principal
axes, while <span class="math notranslate nohighlight">\(\mathbf{D}\)</span> is a diagonal matrix whose three diagonal
elements are the lengths of the principal axes.</p></li>
<li><p><strong>a</strong> (<em>np.ndarray</em><em> of </em><em>shape</em><em> (</em><em>3</em><em>,</em><em>)</em>) – Vectorial center of the trivariate Gaussian.</p></li>
<li><p><strong>maxdeg</strong> (<em>int</em>) – Maximum degree for which the moments need to be computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>The list of moments defined as</p>
<div class="math notranslate nohighlight">
\[\langle x^{n_0} y^{n_1} z^{n_2} \rangle =
    \int(x^{n_0} y^{n_1} z^{n_2}) \exp(-0.5(r-a)^T \Sigma (r-a)) dx\,dy\,dz\,
    \sum_{i=1}^{\infty} x_{i}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Sigma\)</span> is the covariance matrix.</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that the term “moments” in probability theory are defined for normalized Gaussian distributions. These
recursive relations find the moments of a normalized Gaussian, but we actually want to find the moments of
the unnormalized underlying gaussian (as seen in the equation above) because calculating expansion
coefficients of any density should not involve normalization. Therefore, we scale the end-result by
global_factor, which is the reciprocal of the normalizing constant in front of any gaussian.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anisoap.utils.moment_generator.compute_moments_single_variable">
<span class="sig-prename descclassname"><span class="pre">anisoap.utils.moment_generator.</span></span><span class="sig-name descname"><span class="pre">compute_moments_single_variable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxdeg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.utils.moment_generator.compute_moments_single_variable" title="Link to this definition"></a></dt>
<dd><p>Computes all moments for a single variable Gaussian.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>A</strong> (<em>float</em>) – inverse of variance (see below for exact mathematical form)</p></li>
<li><p><strong>a</strong> (<em>float</em>) – Center of Gaussian function</p></li>
<li><p><strong>maxdeg</strong> (<em>int</em>) – Maximum degree for which the moments need to be computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A numpy array of size (<cite>maxdeg</cite> + 1,) containing the moments defined as</p>
<div class="math notranslate nohighlight">
\[\langle x^n \rangle = \int x^n e^{-A(x-a)^2/2} dx\]</div>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Gaussian is not normalized, meaning that we need to multiply
all results by a global factor if we wish to interpret these as moments of
a probability density.</p>
</div>
</dd></dl>

<dl class="py class" id="module-anisoap.utils.monomial_iterator">
<dt class="sig sig-object py" id="anisoap.utils.monomial_iterator.TrivariateMonomialIndices">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">anisoap.utils.monomial_iterator.</span></span><span class="sig-name descname"><span class="pre">TrivariateMonomialIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deg</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.utils.monomial_iterator.TrivariateMonomialIndices" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class for generating an iterator object over trivariate monomials.</p>
<p>Generates an iterator object over trivariate monomials of the form
<span class="math notranslate nohighlight">\(f(x,y,z) = x^{n_0} y^{n_1} z^{n_2}\)</span> sorted in lexicographical order.</p>
<p>Without this class, iterating over all monomials at some fixed degree
requires the use of a double loop of the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">n0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">deg</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">deg</span><span class="o">-</span><span class="n">n0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">deg</span> <span class="o">-</span> <span class="n">n0</span> <span class="o">-</span> <span class="n">n1</span>

        <span class="o">...</span> <span class="c1"># do something with exponents (n0,n1,n2)</span>

        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Instead, with this class, these lines can be reduced to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">myiter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">TrivariateMonomialIndices</span><span class="p">(</span><span class="n">deg</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">myiter</span><span class="p">:</span>
    <span class="o">...</span> <span class="c1"># do something with exponents (n0, n1, n2)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="anisoap.utils.monomial_iterator.TrivariateMonomialIndices.find_idx">
<span class="sig-name descname"><span class="pre">find_idx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">exponents</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.utils.monomial_iterator.TrivariateMonomialIndices.find_idx" title="Link to this definition"></a></dt>
<dd><p>Finds the index of a given tuple of exponents.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>exponents</strong> (<em>3-tuple</em><em> of </em><em>the form</em><em> (</em><em>n0</em><em>, </em><em>n1</em><em>, </em><em>n2</em><em>)</em>) – The exponents of the monomial <span class="math notranslate nohighlight">\(x^{n_0}  y^{n_1} z^{n_2}\)</span></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The index of the tuple in lexicographical order</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function" id="module-anisoap.utils.spherical_to_cartesian">
<span id="module-anisoap.utils.shortcuts"></span><dt class="sig sig-object py" id="anisoap.utils.spherical_to_cartesian.prefact_minus1">
<span class="sig-prename descclassname"><span class="pre">anisoap.utils.spherical_to_cartesian.</span></span><span class="sig-name descname"><span class="pre">prefact_minus1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.utils.spherical_to_cartesian.prefact_minus1" title="Link to this definition"></a></dt>
<dd><p>Computes the prefactor that multiplies the <span class="math notranslate nohighlight">\(T_{l-1}^\text{th}\)</span> term in the iteration.</p>
<p>For <span class="math notranslate nohighlight">\(m \in \left[-l, -l+2, ..., l \right]\)</span>, compute the factor as</p>
<div class="math notranslate nohighlight">
\[\left( \frac{\sqrt{(l+1-m)!}}{(l+1+m)!} \right) \left( \frac{\sqrt{(l+m)!}}{(l-m)!} \right)
    \left( \frac{2l+1}{l+1-m} \right)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>l</strong> (<em>int</em>) – Term immediately proceeding the term for which the prefactor is computed.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>corresponds to the prefactor that multiplies the <span class="math notranslate nohighlight">\(T_{l-1}^\text{th}\)</span>
term in the iteration</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of size (2l + 1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anisoap.utils.spherical_to_cartesian.prefact_minus2">
<span class="sig-prename descclassname"><span class="pre">anisoap.utils.spherical_to_cartesian.</span></span><span class="sig-name descname"><span class="pre">prefact_minus2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.utils.spherical_to_cartesian.prefact_minus2" title="Link to this definition"></a></dt>
<dd><p>Computes the prefactor that multiplies the <span class="math notranslate nohighlight">\(T_{l-2}^\text{th}\)</span> term in the iteration.</p>
<p>For <span class="math notranslate nohighlight">\(m \in \left[-l+1, -l+2, ..., l-1\right]\)</span>, compute the factor as</p>
<div class="math notranslate nohighlight">
\[\left( \frac{\sqrt{(l+1-m)!}}{(l+1+m)!} \right) \left(\frac{\sqrt{(l-1+m)!}}{(l-1-m)!} \right)
    \left( \frac{l+m}{l-m+1} \right)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>l</strong> (<em>int</em>) – Term two places after the term for which the prefactor is computed</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Corresponds to the prefactor that multiplies the term in question</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of size (2l - 1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anisoap.utils.spherical_to_cartesian.spherical_to_cartesian">
<span class="sig-prename descclassname"><span class="pre">anisoap.utils.spherical_to_cartesian.</span></span><span class="sig-name descname"><span class="pre">spherical_to_cartesian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_ns</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anisoap.utils.spherical_to_cartesian.spherical_to_cartesian" title="Link to this definition"></a></dt>
<dd><p>Finds the coefficients for the cartesian polynomial form of solid harmonics
<span class="math notranslate nohighlight">\(R_{lm} = \sqrt{(4\pi)/(2l+1)}*r^l*Y_{lm}\)</span>.  Note that our AniSOAP
expansion does not contain the <span class="math notranslate nohighlight">\(\sqrt{(4\pi)/(2l+1)}\)</span> prefactor, so in calculating
expansion coefficients, we need to divide by that coefficient.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lmax</strong> (<em>int</em>)</p></li>
<li><p><strong>num_ns</strong> (<em>int</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="usage.html" class="btn btn-neutral float-left" title="Usage" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Cersonsky Lab.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>